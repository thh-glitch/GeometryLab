<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometry Designer Deluxe</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Import Map -->
    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "three": "https://esm.sh/three@0.160.0",
            "lucide-react": "https://esm.sh/lucide-react@0.300.0?deps=react@18.2.0",
            "canvas-confetti": "https://esm.sh/canvas-confetti@1.6.0",
            "recharts": "https://esm.sh/recharts@2.10.3?deps=react@18.2.0"
        }
    }
    </script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #f8fafc; font-family: 'Inter', sans-serif; }
        
        .glass-panel {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 10px 40px -10px rgba(0, 0, 0, 0.1);
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in { animation: fadeIn 0.4s ease-out forwards; }
        
        @keyframes pulse-subtle {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        .animate-pulse-subtle { animation: pulse-subtle 2s infinite ease-in-out; }

        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 24px; width: 24px;
            border-radius: 50%;
            background: #4f46e5;
            margin-top: -10px;
            box-shadow: 0 4px 6px -1px rgba(79, 70, 229, 0.4);
            cursor: pointer;
            transition: transform 0.1s;
            border: 2px solid white;
        }
        input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.1); }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 6px;
            background: #e2e8f0; border-radius: 3px;
        }
        
        /* Chart Tooltip Customization */
        .recharts-tooltip-wrapper {
            z-index: 1000;
        }
    </style>
    
    <!-- Error Suppression Script -->
    <script>
        // Suppress benign ResizeObserver loop errors
        const _ResizeObserver = window.ResizeObserver;
        window.ResizeObserver = class ResizeObserver extends _ResizeObserver {
            constructor(callback) {
                callback = (origCallback => (entries, observer) => {
                    window.requestAnimationFrame(() => {
                        origCallback(entries, observer);
                    });
                })(callback);
                super(callback);
            }
        };
    </script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef, useMemo } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { Box, Cylinder, Cone, Trophy, AlertCircle, RotateCcw, Ruler, DollarSign, Leaf, Package, Calculator, Sparkles, Zap, CheckCircle2, XCircle, ArrowRight, TrendingUp, Smartphone, Grid3X3, Coins, Pencil } from 'lucide-react';
        import confetti from 'canvas-confetti';
        import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, ReferenceDot } from 'recharts';

        const formatNum = (num) => parseFloat(num.toFixed(1));

        // --- Shape Database ---
        const SHAPES = {
            cylinder: {
                id: 'cylinder',
                name: 'Cylinder',
                realName: 'Soda Can',
                icon: <Cylinder size={24} />,
                limits: { radius: [1.5, 6], height: [2, 12] },
                formulas: { volume: (p) => Math.PI * Math.pow(p.radius, 2) * p.height, area: (p) => 2 * Math.PI * p.radius * p.height + 2 * Math.PI * Math.pow(p.radius, 2), tex: 'V = πr²h' },
                matProps: { metalness: 0.6, roughness: 0.3, clearcoat: 0.8, color: 0xef4444 }
            },
            cone: {
                id: 'cone',
                name: 'Cone',
                realName: 'Premium Cone',
                icon: <div className="rotate-180"><Cone size={24} /></div>, 
                limits: { radius: [2, 7], height: [3, 14] },
                formulas: { volume: (p) => (1/3) * Math.PI * Math.pow(p.radius, 2) * p.height, area: (p) => Math.PI * p.radius * (p.radius + Math.sqrt(p.radius**2 + p.height**2)), tex: 'V = ⅓πr²h' },
                matProps: { metalness: 0.1, roughness: 0.6, clearcoat: 0, color: 0xf59e0b }
            },
            cube: {
                id: 'cube',
                name: 'Cuboid',
                realName: 'Shipping Box',
                icon: <Box size={24} />,
                limits: { width: [2, 8], height: [2, 8], depth: [2, 8] },
                formulas: { volume: (p) => p.width * p.height * p.depth, area: (p) => 2 * (p.width * p.depth + p.height * p.depth + p.width * p.height), tex: 'V = lwh' },
                matProps: { metalness: 0.0, roughness: 0.9, clearcoat: 0, color: 0x854d0e }
            }
        };

        // --- Chart Component for Explore Mode ---
        const OptimizationChart = ({ shapeId, currentParams, currentArea }) => {
            const data = useMemo(() => {
                if (shapeId !== 'cylinder') return [];
                const fixedVol = Math.PI * Math.pow(currentParams.radius, 2) * currentParams.height;
                const points = [];
                for (let r = 1.5; r <= 6; r += 0.2) {
                    const h = fixedVol / (Math.PI * r * r);
                    if (h > 15 || h < 1) continue;
                    const a = 2 * Math.PI * r * h + 2 * Math.PI * r * r;
                    points.push({ r: parseFloat(r.toFixed(1)), area: Math.round(a) });
                }
                return points;
            }, [shapeId, currentParams.radius, currentParams.height]);

            if (shapeId !== 'cylinder') return (
                <div className="h-32 flex items-center justify-center text-slate-400 text-xs bg-slate-50 rounded-xl border border-slate-200 mt-4">
                    Optimization graph available for Cylinder
                </div>
            );

            return (
                <div className="h-48 w-full mt-4 bg-white rounded-xl p-2 border border-slate-200 shadow-sm">
                    <div className="text-[10px] font-bold text-indigo-500 mb-2 uppercase tracking-wider flex items-center gap-1">
                        <TrendingUp size={12}/> Surface Area vs Radius (Fixed Vol)
                    </div>
                    <div style={{ width: '100%', height: '130px' }}>
                        <ResponsiveContainer>
                            <LineChart data={data}>
                                <CartesianGrid strokeDasharray="3 3" stroke="#e2e8f0" />
                                <XAxis dataKey="r" fontSize={10} tick={{fill: '#94a3b8'}} />
                                <YAxis fontSize={10} tick={{fill: '#94a3b8'}} domain={['auto', 'auto']} hide />
                                <Tooltip 
                                    contentStyle={{background: '#fff', borderRadius: '8px', border: 'none', boxShadow: '0 4px 12px rgba(0,0,0,0.1)'}}
                                    itemStyle={{fontSize: '12px', color: '#6366f1', fontWeight: 'bold'}}
                                    labelStyle={{display: 'none'}}
                                    formatter={(value) => [`${value} cm²`, 'Area']}
                                />
                                <Line type="monotone" dataKey="area" stroke="#6366f1" strokeWidth={2} dot={false} />
                                <ReferenceDot x={currentParams.radius} y={Math.round(currentArea)} r={4} fill="#ef4444" stroke="#fff" />
                            </LineChart>
                        </ResponsiveContainer>
                    </div>
                </div>
            );
        };

        const GeometryLab = () => {
            const mountRef = useRef(null);
            
            // State
            const [mode, setMode] = useState('explore'); 
            const [currentShapeId, setCurrentShapeId] = useState('cylinder');
            const [params, setParams] = useState({ radius: 3, height: 5, width: 4, depth: 4 }); 
            const [scenario, setScenario] = useState(null);
            const [gameState, setGameState] = useState('playing'); 
            const [validation, setValidation] = useState({ vol: false, constraint: false });
            const [streak, setStreak] = useState(0);
            
            // Toggles
            const [showNet, setShowNet] = useState(false); 
            const [showRefObj, setShowRefObj] = useState(false); 

            // Three.js Refs
            const sceneRef = useRef(null);
            const meshRef = useRef(null);
            const netRef = useRef(null); 
            const refObjRef = useRef(null); 
            const rendererRef = useRef(null);
            const cameraRef = useRef(null);
            const animationFrameRef = useRef(null);
            const isDragging = useRef(false);
            const previousMousePosition = useRef({ x: 0, y: 0 });
            const rotationRef = useRef({ x: 0.5, y: 0.8 }); 

            const shapeConfig = SHAPES[currentShapeId];
            const currentVolume = shapeConfig.formulas.volume(params);
            const currentArea = shapeConfig.formulas.area(params);

            const calculateProfit = () => {
                if (scenario && scenario.type === 'tycoon') {
                    const revenue = currentVolume * 0.05;
                    const cost = currentArea * 0.02;
                    return (revenue - cost).toFixed(2);
                }
                return 0;
            };

            // --- Scenarios ---
            const generateScenario = () => {
                const scenarios = [
                    {
                        type: 'eco', shapeId: 'cylinder', title: 'Eco-Can Project', icon: <Leaf className="text-emerald-600" />,
                        desc: 'Design a sustainable soda can. Minimize surface area (aluminum) for the target volume.',
                        gen: () => {
                            const v = Math.floor(Math.random() * 200) + 300; 
                            const r_ideal = Math.pow(v / (2 * Math.PI), 1/3);
                            const a_ideal = 2 * Math.PI * r_ideal * (2 * r_ideal) + 2 * Math.PI * r_ideal * r_ideal; 
                            return { targetVolume: v, constraintType: 'area', constraintValue: Math.ceil(a_ideal * 1.15), constraintText: `Area < ${Math.ceil(a_ideal * 1.15)}` };
                        }
                    },
                    {
                        type: 'tycoon', shapeId: 'cylinder', title: 'Factory Tycoon', icon: <Coins className="text-amber-500" />,
                        desc: 'Maximize profit! Revenue: $0.05/ml, Cost: $0.02/cm². Optimize dimensions to increase margin.',
                        gen: () => {
                            const v = 350; 
                            const r_ideal = Math.pow(v / (2 * Math.PI), 1/3);
                            const a_ideal = 2 * Math.PI * r_ideal * (2 * r_ideal) + 2 * Math.PI * r_ideal * r_ideal;
                            const max_profit = (v * 0.05) - (a_ideal * 0.02);
                            const target_profit = max_profit * 0.95; 
                            
                            return { 
                                targetVolume: v, 
                                constraintType: 'profit', 
                                constraintValue: parseFloat(target_profit.toFixed(2)), 
                                constraintText: `Profit > $${target_profit.toFixed(2)}` 
                            };
                        }
                    },
                    {
                        type: 'logistics', shapeId: 'cube', title: 'Shelf Master', icon: <Package className="text-blue-600" />,
                        desc: 'Fit the cereal box onto a specific shelf height while meeting volume targets.',
                        gen: () => {
                            const v = Math.floor(Math.random() * 300) + 500; 
                            const h = Math.floor(Math.random() * 3) + 6; 
                            return { targetVolume: v, constraintType: 'height', constraintValue: h, constraintText: `Height ≤ ${h} cm` };
                        }
                    }
                ];

                const rnd = scenarios[Math.floor(Math.random() * scenarios.length)];
                const details = rnd.gen();
                
                setCurrentShapeId(rnd.shapeId);
                setScenario({ ...rnd, ...details });
                setGameState('playing');
                setValidation({ vol: false, constraint: false });
                setParams({ radius: 3, height: 5, width: 4, depth: 4 }); 
                setShowNet(false); 
            };

            useEffect(() => { if (mode === 'game' && !scenario) generateScenario(); }, [mode]);

            useEffect(() => {
                if (!scenario || mode !== 'game') return;
                const isVolOk = Math.abs(currentVolume - scenario.targetVolume) < (scenario.targetVolume * 0.05);
                let isConstraintOk = false;
                
                if (scenario.constraintType === 'area') isConstraintOk = currentArea <= scenario.constraintValue;
                else if (scenario.constraintType === 'height') isConstraintOk = params.height <= scenario.constraintValue;
                else if (scenario.constraintType === 'profit') isConstraintOk = parseFloat(calculateProfit()) >= scenario.constraintValue;

                setValidation({ vol: isVolOk, constraint: isConstraintOk });
            }, [currentVolume, currentArea, params, scenario, mode]);

            const handleSubmit = () => {
                if (validation.vol && validation.constraint) {
                    setGameState('success');
                    setStreak(s => s + 1);
                    confetti({
                        particleCount: 150, spread: 70, origin: { y: 0.6 },
                        colors: ['#6366f1', '#10b981', '#f43f5e']
                    });
                }
            };
            
            const updateParam = (k, v) => setParams(p => ({ ...p, [k]: parseFloat(v) }));

            // --- Three.js Setup ---
            useEffect(() => {
                if (!mountRef.current) return;
                const scene = new THREE.Scene();
                
                const width = mountRef.current.clientWidth;
                const height = mountRef.current.clientHeight;
                const camera = new THREE.PerspectiveCamera(40, width / height, 0.1, 100);
                camera.position.set(12, 10, 12);
                camera.lookAt(0, 3, 0); 

                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(width, height);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.shadowMap.enabled = true;
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                
                mountRef.current.appendChild(renderer.domElement);
                sceneRef.current = scene;
                cameraRef.current = camera;
                rendererRef.current = renderer;

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
                mainLight.position.set(5, 12, 8);
                mainLight.castShadow = true;
                mainLight.shadow.mapSize.width = 1024;
                mainLight.shadow.mapSize.height = 1024;
                scene.add(mainLight);
                const fillLight = new THREE.DirectionalLight(0xbfdbfe, 0.6);
                fillLight.position.set(-5, 5, -5);
                scene.add(fillLight);

                // Floor Grid
                const gridHelper = new THREE.GridHelper(30, 30, 0x94a3b8, 0xe2e8f0);
                scene.add(gridHelper);

                // Reference Object: Pencil
                const pencilGroup = new THREE.Group();
                // Body
                const body = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 14, 6), new THREE.MeshStandardMaterial({ color: 0xfacc15, roughness: 0.6 }));
                pencilGroup.add(body);
                // Ferrule
                const ferrule = new THREE.Mesh(new THREE.CylinderGeometry(0.36, 0.36, 1.5, 32), new THREE.MeshStandardMaterial({ color: 0xc0c0c0, metalness: 0.7, roughness: 0.3 }));
                ferrule.position.y = 7.75;
                pencilGroup.add(ferrule);
                // Eraser
                const eraser = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 1.5, 32), new THREE.MeshStandardMaterial({ color: 0xf472b6, roughness: 0.9 }));
                eraser.position.y = 9.25;
                pencilGroup.add(eraser);
                // Wood
                const wood = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.1, 2, 32), new THREE.MeshStandardMaterial({ color: 0xfde68a, roughness: 1.0 }));
                wood.position.y = -8;
                pencilGroup.add(wood);
                // Lead
                const lead = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.02, 0.5, 32), new THREE.MeshStandardMaterial({ color: 0x1f2937, roughness: 1.0 }));
                lead.position.y = -9.25;
                pencilGroup.add(lead);

                pencilGroup.rotation.z = Math.PI / 2;
                pencilGroup.rotation.y = -Math.PI / 4;
                pencilGroup.position.set(8, 0.4, 2);
                pencilGroup.visible = false;
                scene.add(pencilGroup);
                refObjRef.current = pencilGroup;

                // Animation
                const animate = () => {
                    if (meshRef.current && !isDragging.current) {
                        meshRef.current.rotation.y += 0.003;
                        if (netRef.current) netRef.current.rotation.y += 0.003;
                    } else if (meshRef.current) {
                         meshRef.current.rotation.y = rotationRef.current.y;
                         meshRef.current.rotation.x = rotationRef.current.x;
                         if (netRef.current) {
                             netRef.current.rotation.y = rotationRef.current.y;
                             netRef.current.rotation.x = rotationRef.current.x;
                         }
                    }
                    if (rendererRef.current && sceneRef.current && cameraRef.current) {
                        rendererRef.current.render(sceneRef.current, cameraRef.current);
                    }
                    animationFrameRef.current = requestAnimationFrame(animate);
                };
                animate();

                // Resize
                const resizeObserver = new ResizeObserver((entries) => {
                    if (!Array.isArray(entries) || !entries.length) return;
                    if (mountRef.current && cameraRef.current && rendererRef.current) {
                        const w = mountRef.current.clientWidth;
                        const h = mountRef.current.clientHeight;
                        if (w > 0 && h > 0) {
                            cameraRef.current.aspect = w / h;
                            cameraRef.current.updateProjectionMatrix();
                            rendererRef.current.setSize(w, h);
                        }
                    }
                });
                resizeObserver.observe(mountRef.current);

                return () => {
                    resizeObserver.disconnect();
                    if (mountRef.current && renderer.domElement) mountRef.current.removeChild(renderer.domElement);
                    if (animationFrameRef.current) cancelAnimationFrame(animationFrameRef.current);
                    renderer.dispose();
                };
            }, []);

            // Update Mesh & Net
            useEffect(() => {
                if (!sceneRef.current) return;
                
                if (meshRef.current) {
                    sceneRef.current.remove(meshRef.current);
                    meshRef.current.traverse(c => { if(c.geometry) c.geometry.dispose(); if(c.material) c.material.dispose(); });
                }
                if (netRef.current) {
                    sceneRef.current.remove(netRef.current);
                    netRef.current.traverse(c => { if(c.geometry) c.geometry.dispose(); if(c.material) c.material.dispose(); });
                }

                const p = params;
                const scale = 0.5;
                let geo;
                if (currentShapeId === 'cube') geo = new THREE.BoxGeometry(p.width*scale, p.height*scale, p.depth*scale);
                else if (currentShapeId === 'cylinder') geo = new THREE.CylinderGeometry(p.radius*scale, p.radius*scale, p.height*scale, 64);
                else geo = new THREE.CylinderGeometry(0, p.radius*scale, p.height*scale, 64);

                const isSuccess = mode === 'game' && validation.vol && validation.constraint;
                const baseColor = isSuccess ? 0x10b981 : (mode === 'explore' ? 0x3b82f6 : shapeConfig.matProps.color);
                
                const material = new THREE.MeshPhysicalMaterial({
                    color: baseColor,
                    metalness: shapeConfig.matProps.metalness,
                    roughness: shapeConfig.matProps.roughness,
                    clearcoat: shapeConfig.matProps.clearcoat,
                    transparent: true,
                    opacity: showNet ? 0.2 : 0.95 
                });

                const mesh = new THREE.Mesh(geo, material);
                mesh.castShadow = true;
                mesh.position.y = (p.height * scale) / 2;
                const edges = new THREE.LineSegments(
                    new THREE.EdgesGeometry(geo),
                    new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true })
                );
                mesh.add(edges);

                mesh.rotation.x = rotationRef.current.x;
                mesh.rotation.y = rotationRef.current.y;
                sceneRef.current.add(mesh);
                meshRef.current = mesh;

                if (showNet) {
                    const netGroup = new THREE.Group();
                    const netMat = new THREE.MeshBasicMaterial({ color: baseColor, side: THREE.DoubleSide, transparent: true, opacity: 0.8 });
                    
                    if (currentShapeId === 'cylinder') {
                        const c = 2 * Math.PI * p.radius * scale;
                        const h = p.height * scale;
                        const body = new THREE.Mesh(new THREE.PlaneGeometry(c, h), netMat);
                        body.position.set(0, h/2, 0);
                        netGroup.add(body);
                        const top = new THREE.Mesh(new THREE.CircleGeometry(p.radius * scale, 32), netMat);
                        top.position.set(0, h + p.radius*scale + 0.2, 0);
                        netGroup.add(top);
                        const bot = new THREE.Mesh(new THREE.CircleGeometry(p.radius * scale, 32), netMat);
                        bot.position.set(0, -p.radius*scale - 0.2, 0);
                        netGroup.add(bot);
                    } else if (currentShapeId === 'cube') {
                        const w = p.width * scale; const h = p.height * scale; const d = p.depth * scale;
                        const center = new THREE.Mesh(new THREE.PlaneGeometry(w, h), netMat);
                        netGroup.add(center);
                        const top = new THREE.Mesh(new THREE.PlaneGeometry(w, d), netMat); top.position.y = h/2 + d/2; netGroup.add(top);
                        const bot = new THREE.Mesh(new THREE.PlaneGeometry(w, d), netMat); bot.position.y = -h/2 - d/2; netGroup.add(bot);
                        const left = new THREE.Mesh(new THREE.PlaneGeometry(d, h), netMat); left.position.x = -w/2 - d/2; netGroup.add(left);
                        const right = new THREE.Mesh(new THREE.PlaneGeometry(d, h), netMat); right.position.x = w/2 + d/2; netGroup.add(right);
                        const back = new THREE.Mesh(new THREE.PlaneGeometry(w, h), netMat); back.position.x = w/2 + d + w/2; netGroup.add(back);
                    }
                    netGroup.position.set(-8, 4, 0);
                    netGroup.rotation.y = Math.PI / 4;
                    sceneRef.current.add(netGroup);
                    netRef.current = netGroup;
                }

                if (refObjRef.current) refObjRef.current.visible = showRefObj;

            }, [currentShapeId, params, mode, validation, showNet, showRefObj]);

            const handleMouseDown = (e) => { isDragging.current = true; previousMousePosition.current = { x: e.clientX, y: e.clientY }; };
            const handleMouseMove = (e) => {
                if (!isDragging.current) return;
                const delta = { x: e.clientX - previousMousePosition.current.x, y: e.clientY - previousMousePosition.current.y };
                rotationRef.current.y += delta.x * 0.01;
                rotationRef.current.x += delta.y * 0.01;
                previousMousePosition.current = { x: e.clientX, y: e.clientY };
            };
            const handleMouseUp = () => isDragging.current = false;

            return (
                <div className="flex w-full h-screen bg-slate-50 text-slate-800 overflow-hidden" 
                     onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp}>
                    
                    {/* Sidebar */}
                    <aside className="w-[420px] m-4 flex flex-col z-20 shadow-2xl rounded-3xl glass-panel animate-fade-in overflow-hidden h-[calc(100vh-2rem)] border border-white/60">
                        
                        {/* Header */}
                        <div className="p-6 border-b border-slate-200/60 bg-white/60 backdrop-blur-md">
                            <div className="flex items-center justify-between mb-4">
                                <div className="flex items-center gap-3">
                                    <div className="bg-indigo-600 p-2.5 rounded-xl text-white shadow-lg shadow-indigo-500/30">
                                        <Package size={24} strokeWidth={2.5} />
                                    </div>
                                    <div>
                                        <h1 className="text-xl font-extrabold text-slate-800 tracking-tight">GeoDesigner</h1>
                                        <p className="text-[10px] font-bold text-indigo-600 uppercase tracking-widest">Factory Edition</p>
                                    </div>
                                </div>
                                {mode === 'game' && (
                                    <div className="flex items-center gap-1.5 bg-gradient-to-r from-amber-100 to-orange-100 text-amber-700 px-3 py-1.5 rounded-full text-xs font-bold border border-amber-200 shadow-sm">
                                        <Zap size={14} fill="currentColor" />
                                        Streak: {streak}
                                    </div>
                                )}
                            </div>

                            <div className="flex bg-slate-100/80 p-1.5 rounded-xl relative border border-slate-200">
                                <div className={`absolute top-1.5 bottom-1.5 w-[50%] bg-white rounded-lg shadow-sm transition-all duration-300 ${mode === 'game' ? 'left-[49%]' : 'left-1.5'}`}></div>
                                <button onClick={() => {setMode('explore'); setGameState('playing')}} className={`flex-1 relative z-10 py-2 text-sm font-bold rounded-lg transition-colors ${mode === 'explore' ? 'text-indigo-600' : 'text-slate-500 hover:text-slate-700'}`}>
                                    Explore
                                </button>
                                <button onClick={() => {setMode('game'); generateScenario()}} className={`flex-1 relative z-10 py-2 text-sm font-bold rounded-lg transition-colors ${mode === 'game' ? 'text-rose-600' : 'text-slate-500 hover:text-slate-700'}`}>
                                    Challenge
                                </button>
                            </div>
                        </div>

                        {/* Content Area */}
                        <div className="flex-1 overflow-y-auto p-6 space-y-6 bg-gradient-to-b from-white/40 to-transparent">
                            
                            {mode === 'game' && scenario ? (
                                <div className="animate-fade-in space-y-6">
                                    {/* Mission Info */}
                                    <div className={`rounded-2xl p-5 border shadow-sm relative overflow-hidden transition-all duration-300 ${gameState === 'success' ? 'bg-green-50 border-green-200' : 'bg-white border-indigo-50'}`}>
                                        <div className="flex items-start gap-4 relative z-10">
                                            <div className="p-3 bg-indigo-50 rounded-2xl text-indigo-600 border border-indigo-100 shadow-sm">
                                                {scenario.icon}
                                            </div>
                                            <div>
                                                <h3 className="font-bold text-lg text-slate-800 leading-tight">{scenario.title}</h3>
                                                <p className="text-sm text-slate-500 leading-snug mt-1 font-medium">{scenario.desc}</p>
                                            </div>
                                        </div>
                                    </div>

                                    {/* DASHBOARD */}
                                    <div className="bg-white rounded-3xl p-1 shadow-lg border border-slate-100">
                                        {/* Target 1: Volume */}
                                        <div className="p-4 border-b border-slate-100">
                                            <div className="flex justify-between items-center mb-2">
                                                <div className="flex items-center gap-2">
                                                    <div className={`w-2 h-8 rounded-full ${validation.vol ? 'bg-emerald-500' : 'bg-indigo-500'}`}></div>
                                                    <div>
                                                        <span className="text-[10px] font-bold uppercase tracking-wider text-slate-400 block">Target Volume</span>
                                                        <span className="text-xl font-black text-slate-800">{scenario.targetVolume} <span className="text-sm font-bold text-slate-400">ml</span></span>
                                                    </div>
                                                </div>
                                                <div className={`px-3 py-1 rounded-full text-xs font-bold ${validation.vol ? 'bg-emerald-100 text-emerald-700' : 'bg-slate-100 text-slate-500'}`}>
                                                    {validation.vol ? 'Matched' : 'Adjusting...'}
                                                </div>
                                            </div>
                                            <div className="relative h-4 bg-slate-100 rounded-full overflow-hidden mt-2">
                                                <div className="absolute top-0 bottom-0 left-[47.5%] w-[5%] bg-emerald-200/50 border-x border-emerald-300 z-10"></div>
                                                <div className={`absolute top-0 bottom-0 left-0 transition-all duration-300 ${validation.vol ? 'bg-emerald-500' : 'bg-indigo-500'}`} 
                                                     style={{width: `${Math.min(100, (currentVolume / (scenario.targetVolume * 2)) * 100)}%`}}>
                                                </div>
                                            </div>
                                            <div className="flex justify-between text-[10px] text-slate-400 font-bold mt-1 px-1">
                                                <span>0</span>
                                                <span className="text-indigo-600">Current: {formatNum(currentVolume)} ml</span>
                                                <span>Max</span>
                                            </div>
                                        </div>

                                        {/* Target 2: Constraint / Profit */}
                                        <div className="p-4">
                                            <div className="flex justify-between items-center">
                                                <div className="flex items-center gap-2">
                                                    <div className={`w-2 h-8 rounded-full ${validation.constraint ? 'bg-emerald-500' : 'bg-rose-500'}`}></div>
                                                    <div>
                                                        <span className="text-[10px] font-bold uppercase tracking-wider text-slate-400 block">
                                                            {scenario.constraintType === 'profit' ? 'Profit Target' : 'Constraint'}
                                                        </span>
                                                        <span className="text-sm font-bold text-slate-700">{scenario.constraintText}</span>
                                                    </div>
                                                </div>
                                                <div className="text-right">
                                                    <span className="text-[10px] font-bold uppercase text-slate-400 block">Current</span>
                                                    <span className={`text-base font-black ${validation.constraint ? 'text-emerald-600' : 'text-rose-500'}`}>
                                                        {scenario.constraintType === 'area' ? formatNum(currentArea) + ' cm²' : 
                                                         scenario.constraintType === 'profit' ? '$' + calculateProfit() : 
                                                         params.height + ' cm'}
                                                    </span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            ) : (
                                <div className="space-y-6 animate-fade-in">
                                    <div className="flex gap-3">
                                        {Object.values(SHAPES).map(s => (
                                            <button key={s.id} onClick={() => setCurrentShapeId(s.id)} 
                                                className={`flex-1 py-4 flex flex-col items-center gap-2 rounded-2xl border transition-all duration-200 ${currentShapeId === s.id ? 'bg-indigo-50 border-indigo-500 text-indigo-600 shadow-md transform scale-105' : 'bg-white border-slate-200 text-slate-400 hover:bg-slate-50'}`}>
                                                {s.icon}
                                                <span className="text-xs font-bold">{s.name}</span>
                                            </button>
                                        ))}
                                    </div>
                                    
                                    <div className="grid grid-cols-2 gap-3">
                                        <div className="bg-slate-800 p-4 rounded-2xl text-white shadow-xl shadow-slate-300/40">
                                            <div className="text-xs text-slate-400 mb-1">Volume</div>
                                            <div className="text-xl font-mono font-bold text-indigo-300">{formatNum(currentVolume)}</div>
                                        </div>
                                        <div className="bg-white border border-slate-200 p-4 rounded-2xl shadow-sm">
                                            <div className="text-xs text-slate-500 mb-1">Surface Area</div>
                                            <div className="text-xl font-mono font-bold text-slate-700">{formatNum(currentArea)}</div>
                                        </div>
                                    </div>

                                    {/* Toggle Features */}
                                    <div className="flex gap-2">
                                        <button onClick={() => setShowNet(!showNet)} className={`flex-1 py-2 text-xs font-bold rounded-lg border transition-all flex items-center justify-center gap-2 ${showNet ? 'bg-indigo-100 text-indigo-700 border-indigo-200' : 'bg-white text-slate-500 border-slate-200'}`}>
                                            <Grid3X3 size={14}/> {showNet ? 'Hide Net' : 'Show Net'}
                                        </button>
                                        <button onClick={() => setShowRefObj(!showRefObj)} className={`flex-1 py-2 text-xs font-bold rounded-lg border transition-all flex items-center justify-center gap-2 ${showRefObj ? 'bg-indigo-100 text-indigo-700 border-indigo-200' : 'bg-white text-slate-500 border-slate-200'}`}>
                                            <Pencil size={14}/> Ref: Pencil
                                        </button>
                                    </div>

                                    {/* Live Chart */}
                                    <OptimizationChart shapeId={currentShapeId} currentParams={params} currentArea={currentArea} />
                                </div>
                            )}

                            {/* CONTROLS */}
                            <div className="space-y-6 pt-2 pb-4">
                                <div className="flex items-center gap-2 mb-2 text-slate-400">
                                    <Ruler size={14} />
                                    <span className="text-[10px] font-bold uppercase tracking-widest">Adjust Parameters</span>
                                </div>
                                {currentShapeId === 'cube' ? 
                                    ['width', 'depth', 'height'].map(k => <Slider key={k} label={k} val={params[k]} min={SHAPES.cube.limits[k][0]} max={SHAPES.cube.limits[k][1]} onChange={v => updateParam(k, v)} />) :
                                    ['radius', 'height'].map(k => <Slider key={k} label={k} val={params[k]} min={shapeConfig.limits[k][0]} max={shapeConfig.limits[k][1]} onChange={v => updateParam(k, v)} />)
                                }
                            </div>
                        </div>

                        <div className="p-6 border-t border-slate-200 bg-white/60 backdrop-blur-md">
                            {mode === 'game' ? (
                                gameState === 'playing' ? (
                                    <button onClick={handleSubmit} disabled={!validation.vol || !validation.constraint}
                                        className={`w-full py-4 rounded-2xl font-bold text-white shadow-xl transition-all flex items-center justify-center gap-2 transform active:scale-95 ${validation.vol && validation.constraint ? 'bg-emerald-500 hover:bg-emerald-600 shadow-emerald-500/30' : 'bg-slate-300 cursor-not-allowed'}`}>
                                        {validation.vol && validation.constraint ? <><Sparkles size={20}/> Submit Design</> : 'Requirements Not Met'}
                                    </button>
                                ) : (
                                    <button onClick={generateScenario} className="w-full py-4 bg-slate-800 text-white rounded-2xl font-bold hover:bg-slate-700 flex items-center justify-center gap-2 shadow-xl animate-pulse-subtle transform active:scale-95">
                                        <RotateCcw size={20}/> Next Challenge
                                    </button>
                                )
                            ) : (
                                <div className="text-center flex justify-center items-center gap-2 text-xs text-slate-400 font-bold bg-slate-100 py-3 rounded-xl">
                                    <RotateCcw size={14}/> Drag model to rotate view
                                </div>
                            )}
                        </div>
                    </aside>

                    {/* Main 3D Canvas Area */}
                    <main className="flex-1 relative h-full bg-slate-50/50 cursor-move border-l border-slate-200/50" onMouseDown={handleMouseDown} onMouseMove={handleMouseMove}>
                        <div ref={mountRef} className="w-full h-full block" />
                        
                        <div className="absolute top-10 right-10 pointer-events-none opacity-30">
                            <div className="w-64 h-64 bg-indigo-400 rounded-full blur-[120px]"></div>
                        </div>
                        <div className="absolute bottom-10 left-20 pointer-events-none opacity-30">
                            <div className="w-96 h-96 bg-rose-300 rounded-full blur-[140px]"></div>
                        </div>
                    </main>

                </div>
            );
        };

        const Slider = ({ label, val, min, max, onChange }) => (
            <div className="group">
                <div className="flex justify-between mb-2">
                    <label className="text-xs font-bold text-slate-500 uppercase tracking-wider group-hover:text-indigo-600 transition-colors">{label}</label>
                    <span className="text-xs font-mono font-bold bg-white px-3 py-1 rounded-lg shadow-sm text-indigo-600 border border-slate-100">{val} cm</span>
                </div>
                <input type="range" min={min} max={max} step="0.1" value={val} onChange={e => onChange(e.target.value)} 
                    className="w-full h-2 rounded-lg appearance-none cursor-pointer bg-slate-200 hover:bg-indigo-200 transition-colors" />
            </div>
        );

        const root = createRoot(document.getElementById('root'));
        root.render(<GeometryLab />);
    </script>
</body>
</html>
